---
sidebar_position: 0
description: An overview of Blacksmith's Scheduler API, an extremely intuitive component that makes FTC software development much cleaner, much easier, and much faster to develop.
keywords: [ftc, intuitive, scheduler, clean, easy]
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Overview

## What is the Scheduler API?

It's a small library that streamlines the creation of your OpModes- **especially your TeleOps!**

It's provided functionality makes your code easier to create, read, and maintain. ðŸ˜®ðŸ˜®ðŸ˜®ðŸ¤¯ðŸ˜®

*âœ¨ Creating TeleOps has never been easier! âœ¨*

## that literally answered nothing.

Let's take a look at some basic bog-standard TeleOp code:

<Tabs groupId="programming-language">
<TabItem value="java" label="Java">

```java
@TeleOp
public class NotCoolTeleOp extends OpMode {
    @Override
    public void init() {
        // Initialize hardware
    }

    @Override
    public void loop() {
        // Loop code
    }

    // ...300 billion lines later...

    private boolean gamepad1aPreviousState = //...;

    private void checkIfShouldDoSomething() {
       if (gamepad2.a && !gamepad1aPreviousState) { // Messy and ugly and ew ðŸ¤®
           claw.intake();
       } else if (!gamepad2.a && gamepad1aPreviousState) { // Ugly unreadable signal edge detectors
           claw.close();
       } // Can't tell if the driver does this or the codriver at the quick glance
       gamepad1aPreviousState = //...;
    } // ugh imperative hell
}
```

</TabItem>
<TabItem value="kt" label="Kotlin">

```kotlin
@TeleOp
class `NotCoolTeleOpðŸ˜”` : OpMode() {
    override fun init() {
        // Initialize hardware
    }

    override fun loop() {
        // Loop code
    }

    // ...300 billion lines later...

    private var gamepad1aPreviousState = //... (mutable state!!!1!1!1)

    private fun checkIfShouldDoSomething() {
       if (gamepad2.a && !gamepad1aPreviousState) { // Messy and ugly and ew ðŸ¤®
           claw.intake()
       } else if (!gamepad2.a && gamepad1aPreviousState) { // Ugly unreadable signal edge detectors
           claw.close()
       } // Can't tell if the driver does this or the codriver at the quick glance
       gamepad1aPreviousState = //...
    } // ugh imperative hell
}
```

</TabItem>
</Tabs>

Now the same TelpOp after receiving the Scheduler treatment:

<Tabs groupId="programming-language">
<TabItem value="java" label="Java">

```java
@TeleOp
public class CoolTeleOp extends BlackOp {
    private ReforgedGamepad codriver;

    @Override
    public void go() {
        codriver = new ReforgedGamepad(gamepad2);

        describeControls(); // Good idea to move it to a method for readability

        Scheduler.launchOnStart(this, () -> {
            // Any extra loop code (runs after every Listener)
        });
    }

    private void describeControls() {
        codriver.a.onRise(() -> claw.intake()); // Simple and easy to read
        codriver.a.onFall(() -> claw.close()); // Complexity is abstracted away
    }
}
```

</TabItem>
<TabItem value="kt" label="Kotlin">

```kotlin
@TeleOp
class `CoolTeleOpðŸ˜Ž` : BlackOp() {
    private val codriver by createOnGo<ReforgedGamepad> { gamepad2 }

    override fun go() {
        describeControls() // Good idea to move it to a method for readability

        Scheduler.launchOnStart(this) {
            // Any extra loop code (runs after every Listener)
        }
    }

    private fun describeControls() {
        codriver.a.onRise(claw::intake) // Simple and easy to read
        codriver.a.onFall(claw::close) // Complexity is abstracted away
    }
}
```

</TabItem>
</Tabs>

As you can see, it dramatically improves code quality and readability, and makes it easier to develop and maintain-
after all, you no longer have to deal with any logic (at least with the basics).

ðŸš€ *Instead of telling the code exactly what to do, you just tell it what you want!*

## Confused?

### Uh, what are those weird symbols (like `() ->`)?

Those are called [lambdas](https://en.wikipedia.org/wiki/Anonymous_function#Java), and they're simply a way of
passing in functions to other functions to be called later.

The Scheduler API does require some medium-level knowledge of Java, but it's not too hard to learn. You just need to
have surface level knowledge of lambdas and what `this` is and such to use this API.

(I'm assuming if you're using Kotlin, you're already familiar with such higher level concepts)

### What is BlackOp?

You don't need to use this, you can use LinearOpMode if you'd like, but atm the Scheduler doesn't
support normal OpModes.
Check out [this](../black-op/overview) for more info

### (Kotlin) what is createOnGo?

A very nice part of [BlackOp](../black-op/create-on-go-kt). There's a `@CreateOnGo`
[equivalent](../black-op/create-on-go-java) for Java too!

### Wth is a ReforgedGamepad or `codriver.a.onRise`??

Read on, it's described in the docs in a little bit. Or click [here.](./reforged-gamepad)

### What is 'x'?
it's probably described in the docs somewhere, I can't list everything, sorry.
